/-
  Generate OpTypeGenerated.lean from riscv-opcodes instr_dict.json

  Reads the JSON instruction dictionary, extracts instruction names,
  and generates a Lean file with:
  - OpType inductive (one constructor per instruction)
  - ToString OpType instance
  - OpType.fromString function
  - OpType.all list
  - OpType.toIndex / OpType.ofIndex functions
-/

import Lean.Data.Json

open Lean (Json)

/-- Normalize instruction name: lowercase with dots/periods → uppercase with underscores.
    E.g., "fadd_s" → "FADD_S", "fcvt.w.s" → "FCVT_W_S" -/
def normalizeName (s : String) : String :=
  s.toUpper.map fun c => if c == '.' then '_' else c

/-- Instructions to skip (pseudo-instructions that alias CSR ops) -/
def skipInstructions : List String :=
  ["frcsr", "frflags", "frrm", "fscsr", "fsflags", "fsflagsi", "fsrm", "fsrmi"]

/-- Extra instructions not in JSON but needed by the CPU (e.g., Zicsr) -/
def extraInstructions : List String :=
  ["CSRRW", "CSRRS", "CSRRC", "CSRRWI", "CSRRSI", "CSRRCI"]

/-- Extension grouping for organizing the enum with comments -/
structure ExtGroup where
  comment : String
  exts : List String  -- extension keys to match

def extGroups : List ExtGroup :=
  [ { comment := "RV32I Base Integer Instructions", exts := ["rv_i", "rv32_i"] },
    { comment := "M Extension: Integer Multiply/Divide", exts := ["rv_m"] },
    { comment := "F Extension: Single-Precision Floating-Point", exts := ["rv_f"] } ]

def parseHex (s : String) : Option UInt32 :=
  if s.startsWith "0x" || s.startsWith "0X" then
    let hexStr := s.drop 2
    hexStr.foldl (fun acc c =>
      acc.bind fun n =>
        if c.isDigit then some (n * 16 + (c.toNat - '0'.toNat))
        else if 'a' ≤ c && c ≤ 'f' then some (n * 16 + (c.toNat - 'a'.toNat + 10))
        else if 'A' ≤ c && c ≤ 'F' then some (n * 16 + (c.toNat - 'A'.toNat + 10))
        else none
    ) (some 0) |>.map UInt32.ofNat
  else none

def main : IO Unit := do
  -- Read JSON
  let jsonStr ← IO.FS.readFile "third_party/riscv-opcodes/instr_dict.json"
  let json ← match Json.parse jsonStr with
    | .ok j => pure j
    | .error e => throw (IO.userError s!"JSON parse error: {e}")
  let obj ← match json.getObj? with
    | .ok o => pure o
    | .error e => throw (IO.userError s!"Not a JSON object: {e}")

  -- Collect instructions grouped by extension
  let mut instrsByExt : List (String × List String) := []
  for group in extGroups do
    let mut names : List String := []
    for ⟨name, instrJson⟩ in obj.toList do
      if skipInstructions.contains name then continue
      let exts ← match instrJson.getObj? with
        | .ok o => match o.get? "extension" with
          | some extJson => match extJson.getArr? with
            | .ok arr => pure (arr.toList.filterMap fun j => j.getStr?.toOption)
            | .error _ => pure ([] : List String)
          | none => pure ([] : List String)
        | .error _ => pure ([] : List String)
      if exts.any (group.exts.contains ·) then
        names := names ++ [normalizeName name]
    -- Sort alphabetically for stability
    let sorted := names.toArray.qsort (· < ·) |>.toList
    instrsByExt := instrsByExt ++ [(group.comment, sorted)]

  -- Build the full ordered list of constructor names
  let mut allNames : List String := []
  for (_, names) in instrsByExt do
    allNames := allNames ++ names
  -- Add extras
  allNames := allNames ++ extraInstructions

  -- Check for duplicates
  let mut seen : List String := []
  let mut deduped : List String := []
  for n in allNames do
    if !seen.contains n then
      seen := seen ++ [n]
      deduped := deduped ++ [n]
  allNames := deduped

  -- Generate Lean file
  let mut out := ""
  out := out ++ "/-\n"
  out := out ++ "  AUTO-GENERATED by `lake exe generate_optype`\n"
  out := out ++ "  Do not edit manually. Source: third_party/riscv-opcodes/instr_dict.json\n"
  out := out ++ "-/\n\n"
  out := out ++ "namespace Shoumei.RISCV\n\n"

  -- OpType inductive
  out := out ++ "/-- Instruction operation types (auto-generated from riscv-opcodes) -/\n"
  out := out ++ "inductive OpType where\n"
  for (comment, names) in instrsByExt do
    out := out ++ s!"  -- {comment}\n"
    for n in names do
      out := out ++ s!"  | {n} : OpType\n"
  -- Extra group
  out := out ++ "  -- Zicsr: CSR Instructions\n"
  for n in extraInstructions do
    out := out ++ s!"  | {n} : OpType\n"
  out := out ++ "  deriving Repr, BEq, DecidableEq\n\n"

  -- ToString instance (compact format, multiple per line)
  out := out ++ "instance : ToString OpType where\n"
  out := out ++ "  toString := fun\n"
  let mut lineItems : List String := []
  for n in allNames do
    lineItems := lineItems ++ [s!"| .{n} => \"{n}\""]
    if lineItems.length >= 5 then
      out := out ++ "    " ++ String.intercalate " " lineItems ++ "\n"
      lineItems := []
  if !lineItems.isEmpty then
    out := out ++ "    " ++ String.intercalate " " lineItems ++ "\n"
  out := out ++ "\n"

  -- fromString function (handles both underscore and dot variants for F extension)
  out := out ++ "/-- Parse OpType from instruction name (case-insensitive) -/\n"
  out := out ++ "def OpType.fromString (s : String) : Option OpType :=\n"
  out := out ++ "  match s.toUpper with\n"
  for n in allNames do
    -- For F extension names with underscores, also accept dot variant
    -- For F extension names, also accept dot variant (FADD_S → FADD.S)
    let hasFpSuffix := n.endsWith "_S" || n.endsWith "_W" || n.endsWith "_WU" ||
                        n.endsWith "_W_S" || n.endsWith "_WU_S" || n.endsWith "_S_W" || n.endsWith "_S_WU" ||
                        n.endsWith "_X_W" || n.endsWith "_W_X"
    let dotVariant := if hasFpSuffix then
      let dv := n.replace "_" "."
      if dv != n then some dv else none
    else none
    match dotVariant with
    | some dv => out := out ++ s!"  | \"{n}\" | \"{dv}\" => some .{n}\n"
    | none => out := out ++ s!"  | \"{n}\" => some .{n}\n"
  out := out ++ "  | _ => none\n\n"

  -- OpType.all list
  out := out ++ "/-- All OpType constructors in canonical order -/\n"
  out := out ++ "def OpType.all : List OpType :=\n"
  out := out ++ "  ["
  let mut idx := 0
  for n in allNames do
    if idx > 0 then out := out ++ ", "
    if idx % 8 == 0 && idx > 0 then out := out ++ "\n   "
    out := out ++ s!".{n}"
    idx := idx + 1
  out := out ++ "]\n\n"

  -- toIndex
  out := out ++ "/-- Get the index of an OpType in the canonical ordering -/\n"
  out := out ++ "def OpType.toIndex : OpType → Nat\n"
  idx := 0
  for n in allNames do
    out := out ++ s!"  | .{n} => {idx}\n"
    idx := idx + 1
  out := out ++ "\n"

  -- ofIndex
  out := out ++ "/-- Get OpType from canonical index -/\n"
  out := out ++ "def OpType.ofIndex : Nat → Option OpType\n"
  idx := 0
  for n in allNames do
    out := out ++ s!"  | {idx} => some .{n}\n"
    idx := idx + 1
  out := out ++ "  | _ => none\n\n"

  -- resolveMapping: convert (OpType, execOpcode) to (decoderIndex, execOpcode)
  out := out ++ "/-- Resolve a name-based mapping to index-based mapping given a decoder's instruction list.\n"
  out := out ++ "    Returns (decoderIndex, execOpcode) pairs. Silently skips OpTypes not in the decoder list. -/\n"
  out := out ++ "def OpType.resolveMapping (decoderNames : List String) (mapping : List (OpType × Nat)) : List (Nat × Nat) :=\n"
  out := out ++ "  mapping.filterMap fun (op, code) =>\n"
  out := out ++ "    let name := toString op\n"
  out := out ++ "    match decoderNames.findIdx? (· == name) with\n"
  out := out ++ "    | some idx => some (idx, code)\n"
  out := out ++ "    | none => none\n\n"

  out := out ++ "end Shoumei.RISCV\n"

  IO.FS.writeFile "lean/Shoumei/RISCV/OpTypeGenerated.lean" out
  IO.println s!"Generated lean/Shoumei/RISCV/OpTypeGenerated.lean with {allNames.length} OpType constructors"
