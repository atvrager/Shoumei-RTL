//==============================================================================
// tb_cpu.sv - Auto-generated testbench for CPU_RV32IMF_Zicsr_Zifencei_Microcoded_L1I256B_L1D256B_L2512B (cache-line memory)
//
// Generated by Shoumei RTL testbench code generator.
// DO NOT EDIT - regenerate with: lake exe generate_all
//==============================================================================

module tb_cpu #(
    parameter MEM_SIZE_WORDS = 65536,
    parameter TIMEOUT_CYCLES = 100000,
    parameter TOHOST_ADDR    = 32'h1000
,
    parameter PUTCHAR_ADDR    = 32'h1004) (
    input logic clk,
    input logic rst_n,
    // Test status
    output logic        o_test_done,
    output logic        o_test_pass,
    output logic [31:0] o_test_code,
    // Debug outputs
    output logic [31:0] o_cycle_count,
    output logic        o_rob_empty,
    // Memory request observation
    output logic        o_mem_req_valid,
    output logic        o_mem_req_we,
    output logic [31:0] o_mem_req_addr,
    // HTIF
    output logic [31:0] o_tohost,
    // RVVI-TRACE outputs (dual-retire W=2 cosimulation)
    output logic        o_rvvi_valid_0,
    output logic        o_rvvi_valid_1,
    output logic        o_rvvi_trap_0,
    output logic        o_rvvi_trap_1,
    output logic [31:0] o_rvvi_pc_rdata_0,
    output logic [31:0] o_rvvi_pc_rdata_1,
    output logic [31:0] o_rvvi_insn_0,
    output logic [31:0] o_rvvi_insn_1,
    output logic [4:0]  o_rvvi_rd_0,
    output logic [4:0]  o_rvvi_rd_1,
    output logic        o_rvvi_rd_valid_0,
    output logic        o_rvvi_rd_valid_1,
    output logic [31:0] o_rvvi_rd_data_0,
    output logic [31:0] o_rvvi_rd_data_1
);

  // =========================================================================
  // DUT I/O signals
  // =========================================================================
  logic        mem_resp_valid;
  logic        mtip_in;
  logic [255:0] mem_resp_data;
  logic        mem_req_valid;
  logic        mem_req_we;
  logic        rob_empty;
  logic        store_snoop_valid;
  logic        rvvi_retire;
  logic        rvvi_validS0;
  logic        rvvi_validS1;
  logic        rvvi_trapS0;
  logic        rvvi_trapS1;
  logic        rvvi_rd_validS0;
  logic        rvvi_rd_validS1;
  logic [31:0] mem_req_addr;
  logic [255:0] mem_req_data;
  logic [31:0] store_snoop_addr;
  logic [31:0] store_snoop_data;
  logic [31:0] rvvi_pc_0;
  logic [31:0] rvvi_pc_1;
  logic [31:0] rvvi_insn_0;
  logic [31:0] rvvi_insn_1;
  logic [4:0] rvvi_rd_0;
  logic [4:0] rvvi_rd_1;
  logic [31:0] rvvi_rdd_0;
  logic [31:0] rvvi_rdd_1;
  logic        reset;
  assign reset = ~rst_n;

  // =========================================================================
  // DUT instance
  // =========================================================================
  CPU_RV32IMF_Zicsr_Zifencei_Microcoded_L1I256B_L1D256B_L2512B u_cpu (
      .clock(clk),
      .reset(reset),
      .zero(1'b0),
      .one(1'b1),
      .mem_resp_valid(mem_resp_valid),
      .mtip_in(mtip_in),
      .mem_resp_data(mem_resp_data),
      .mem_req_valid(mem_req_valid),
      .mem_req_we(mem_req_we),
      .rob_empty(rob_empty),
      .store_snoop_valid(store_snoop_valid),
      .rvvi_retire(rvvi_retire),
      .rvvi_validS0(rvvi_validS0),
      .rvvi_validS1(rvvi_validS1),
      .rvvi_trapS0(rvvi_trapS0),
      .rvvi_trapS1(rvvi_trapS1),
      .rvvi_rd_validS0(rvvi_rd_validS0),
      .rvvi_rd_validS1(rvvi_rd_validS1),
      .mem_req_addr(mem_req_addr),
      .mem_req_data(mem_req_data),
      .store_snoop_addr(store_snoop_addr),
      .store_snoop_data(store_snoop_data),
      .rvvi_pc_0(rvvi_pc_0),
      .rvvi_pc_1(rvvi_pc_1),
      .rvvi_insn_0(rvvi_insn_0),
      .rvvi_insn_1(rvvi_insn_1),
      .rvvi_rd_0(rvvi_rd_0),
      .rvvi_rd_1(rvvi_rd_1),
      .rvvi_rdd_0(rvvi_rdd_0),
      .rvvi_rdd_1(rvvi_rdd_1)
  );

  // =========================================================================
  // Memory: 256-bit cache-line interface, 1-cycle latency
  // =========================================================================
  logic [31:0] mem [0:MEM_SIZE_WORDS-1];

  // DPI-C: allow C++ to write memory words before simulation starts
  export "DPI-C" function dpi_mem_write;
  function void dpi_mem_write(input int unsigned word_addr, input int unsigned data);
    mem[word_addr] = data;
  endfunction

  // DPI-C: override HTIF address from ELF symbol
  logic [31:0] tohost_addr_r;
  initial tohost_addr_r = TOHOST_ADDR;
  export "DPI-C" function dpi_set_tohost_addr;
  function void dpi_set_tohost_addr(input int unsigned addr);
    tohost_addr_r = addr;
  endfunction

  logic [31:0] putchar_addr_r;
  initial putchar_addr_r = PUTCHAR_ADDR;
  export "DPI-C" function dpi_set_putchar_addr;
  function void dpi_set_putchar_addr(input int unsigned addr);
    putchar_addr_r = addr;
  endfunction

  localparam logic [31:0] MEM_BASE = 32'h00000000;

  function automatic logic [31:0] addr_to_idx(input logic [31:0] addr);
    return (addr - MEM_BASE) >> 2;
  endfunction

  // --- Cache-line memory: 1-cycle read latency, combinational write ---
  logic        mem_pending;
  logic [255:0] mem_read_line;

  always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
      mem_resp_valid <= 1'b0;
      mem_read_line  <= 256'b0;
      mem_pending    <= 1'b0;
    end else begin
      mem_pending    <= 1'b0;
      mem_resp_valid <= 1'b0;

      if (mem_req_valid) begin
        if (mem_req_we) begin
          // Write 8-word cache line (line-aligned address)
          for (int w = 0; w < 8; w++) begin
            mem[addr_to_idx(mem_req_addr) + w] <= mem_req_data[w*32 +: 32];
          end
        end else begin
          // Read 8-word cache line (line-aligned address)
          for (int w = 0; w < 8; w++) begin
            mem_read_line[w*32 +: 32] <= mem[addr_to_idx(mem_req_addr) + w];
          end
          mem_pending <= 1'b1;
        end
      end

      if (mem_pending) begin
        mem_resp_valid <= 1'b1;
      end
    end
  end

  // =========================================================================
  // CLINT: Machine Timer (mtime, mtimecmp, mtip)
  // =========================================================================
  logic [63:0] mtime;
  logic [63:0] mtimecmp;
  wire         mtip = (mtime >= mtimecmp);
  assign       mtip_in = mtip;

  // CLINT MMIO addresses
  localparam logic [31:0] CLINT_MTIMECMP_LO = 32'h02004000;
  localparam logic [31:0] CLINT_MTIMECMP_HI = 32'h02004004;
  localparam logic [31:0] CLINT_MTIME_LO    = 32'h0200BFF8;
  localparam logic [31:0] CLINT_MTIME_HI    = 32'h0200BFFC;

  wire clint_mtimecmp_lo_wr = store_snoop_valid && (store_snoop_addr == CLINT_MTIMECMP_LO);
  wire clint_mtimecmp_hi_wr = store_snoop_valid && (store_snoop_addr == CLINT_MTIMECMP_HI);
  wire clint_mtime_lo_wr    = store_snoop_valid && (store_snoop_addr == CLINT_MTIME_LO);
  wire clint_mtime_hi_wr    = store_snoop_valid && (store_snoop_addr == CLINT_MTIME_HI);

  always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
      mtime    <= 64'b0;
      mtimecmp <= 64'hFFFFFFFFFFFFFFFF;
    end else begin
      mtime <= mtime + 1;
      if (clint_mtimecmp_lo_wr) mtimecmp[31:0]  <= store_snoop_data;
      if (clint_mtimecmp_hi_wr) mtimecmp[63:32] <= store_snoop_data;
      if (clint_mtime_lo_wr)    mtime[31:0]     <= store_snoop_data;
      if (clint_mtime_hi_wr)    mtime[63:32]    <= store_snoop_data;
    end
  end

  // CLINT read intercept: override cache-line response for CLINT addresses
  // When a cache-line read hits the CLINT region (0x02000000-0x0200FFFF),
  // inject CLINT register values into the response data.
  wire clint_region = (mem_req_addr_r[31:16] == 16'h0200);
  logic [31:0] mem_req_addr_r;
  logic        clint_pending_q1;
  logic        clint_pending;

  always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
      mem_req_addr_r  <= 32'b0;
      clint_pending_q1 <= 1'b0;
      clint_pending    <= 1'b0;
    end else begin
      // Pipeline stage 2: align clint_pending with mem_resp_valid (2-cycle latency)
      clint_pending <= clint_pending_q1;
      clint_pending_q1 <= 1'b0;
      if (mem_req_valid && !mem_req_we) begin
        mem_req_addr_r   <= mem_req_addr;
        clint_pending_q1 <= (mem_req_addr[31:16] == 16'h0200);
      end
    end
  end

  // Build CLINT cache line response (8 words aligned to cache line)
  logic [255:0] clint_line;
  always_comb begin
    clint_line = 256'b0;
    case (mem_req_addr_r[15:5])  // cache-line aligned offset within CLINT
      11'h200: begin  // 0x02004000 (mtimecmp)
        clint_line[31:0]   = mtimecmp[31:0];
        clint_line[63:32]  = mtimecmp[63:32];
      end
      11'h5FF: begin  // 0x0200BFE0 (mtime at offset 0x18/0x1C within line)
        clint_line[223:192] = mtime[31:0];
        clint_line[255:224] = mtime[63:32];
      end
      default: ;
    endcase
  end

  assign mem_resp_data = clint_pending ? clint_line : mem_read_line;

  // =========================================================================
  // HTIF: tohost termination (detected from CPU store snoop)
  // =========================================================================
  logic        test_done;
  logic        test_pass;
  logic [31:0] test_code;

  // Monitor CPU store interface directly (bypasses cache hierarchy)
  wire        tohost_store = store_snoop_valid && (store_snoop_addr == tohost_addr_r);

  always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
      test_done <= 1'b0;
      test_pass <= 1'b0;
      test_code <= 32'b0;
    end else begin
      if (tohost_store) begin
        test_code <= store_snoop_data;
        test_pass <= (store_snoop_data == 32'h1);
        test_done <= 1'b1;
      end
    end
  end

  // =========================================================================
  // MMIO putchar: monitor CPU store snoop for putchar address
  // =========================================================================
  wire putchar_store = store_snoop_valid && (store_snoop_addr == putchar_addr_r);

  always_ff @(posedge clk) begin
    if (!reset && putchar_store) begin
      $write("%c", store_snoop_data[7:0]);
    end
  end

  // =========================================================================
  // Cycle counter
  // =========================================================================
  logic [31:0] cycle_count;

  always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
      cycle_count <= 32'b0;
    end else begin
      cycle_count <= cycle_count + 1;
    end
  end

  // =========================================================================
  // Output assignments
  // =========================================================================
  assign o_test_done       = test_done;
  assign o_test_pass       = test_pass;
  assign o_test_code       = test_code;
  assign o_cycle_count     = cycle_count;
  assign o_rob_empty       = rob_empty;
  assign o_mem_req_valid  = mem_req_valid;
  assign o_mem_req_we     = mem_req_we;
  assign o_mem_req_addr   = mem_req_addr;
  assign o_tohost          = test_code;
  assign o_rvvi_valid_0    = rvvi_validS0;
  assign o_rvvi_valid_1    = rvvi_validS1;
  assign o_rvvi_trap_0     = rvvi_trapS0;
  assign o_rvvi_trap_1     = rvvi_trapS1;
  assign o_rvvi_pc_rdata_0 = rvvi_pc_0;
  assign o_rvvi_pc_rdata_1 = rvvi_pc_1;
  assign o_rvvi_insn_0     = rvvi_insn_0;
  assign o_rvvi_insn_1     = rvvi_insn_1;
  assign o_rvvi_rd_0       = rvvi_rd_0;
  assign o_rvvi_rd_1       = rvvi_rd_1;
  assign o_rvvi_rd_valid_0 = rvvi_rd_validS0;
  assign o_rvvi_rd_valid_1 = rvvi_rd_validS1;
  assign o_rvvi_rd_data_0  = rvvi_rdd_0;
  assign o_rvvi_rd_data_1  = rvvi_rdd_1;

endmodule
