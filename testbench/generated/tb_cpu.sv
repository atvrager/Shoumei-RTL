//==============================================================================
// tb_cpu.sv - Auto-generated testbench for CPU_RV32IM
//
// Generated by Shoumei RTL testbench code generator.
// DO NOT EDIT - regenerate with: lake exe generate_all
//==============================================================================

module tb_cpu #(
    parameter MEM_SIZE_WORDS = 16384,
    parameter TIMEOUT_CYCLES = 100000,
    parameter TOHOST_ADDR    = 32'h1000
) (
    input logic clk,
    input logic rst_n,
    // Test status
    output logic        o_test_done,
    output logic        o_test_pass,
    output logic [31:0] o_test_code,
    // Debug outputs
    output logic [31:0] o_fetch_pc,
    output logic        o_rob_empty,
    output logic        o_global_stall,
    output logic [31:0] o_cycle_count,
    // Memory request observation
    output logic        o_dmem_req_valid,
    output logic        o_dmem_req_we,
    output logic [31:0] o_dmem_req_addr,
    output logic [31:0] o_dmem_req_data
);

  // =========================================================================
  // CPU I/O signals
  // =========================================================================
  logic        dmem_req_ready;
  logic        dmem_resp_valid;
  logic [31:0] imem_resp_data;
  logic [31:0] dmem_resp_data;
  logic        fetch_stalled;
  logic        global_stall_out;
  logic        dmem_req_valid;
  logic        dmem_req_we;
  logic        rob_empty;
  logic [31:0] fetch_pc;
  logic [31:0] dmem_req_addr;
  logic [31:0] dmem_req_data;

  logic        reset;
  assign reset = ~rst_n;

  // =========================================================================
  // CPU instance
  // =========================================================================
  CPU_RV32IM u_cpu (
      .clock(clk),
      .reset(reset),
      .zero(1'b0),
      .one(1'b1),
      .dmem_req_ready(dmem_req_ready),
      .dmem_resp_valid(dmem_resp_valid),
      .imem_resp_data(imem_resp_data),
      .dmem_resp_data(dmem_resp_data),
      .fetch_stalled(fetch_stalled),
      .global_stall_out(global_stall_out),
      .dmem_req_valid(dmem_req_valid),
      .dmem_req_we(dmem_req_we),
      .rob_empty(rob_empty),
      .fetch_pc(fetch_pc),
      .dmem_req_addr(dmem_req_addr),
      .dmem_req_data(dmem_req_data)
  );

  // =========================================================================
  // Memory: shared instruction + data, word-addressed
  // =========================================================================
  logic [31:0] mem [0:MEM_SIZE_WORDS-1];

  // DPI-C: allow C++ to write memory words before simulation starts
  export "DPI-C" function dpi_mem_write;
  function void dpi_mem_write(input int unsigned word_addr, input int unsigned data);
    mem[word_addr] = data;
  endfunction

  localparam logic [31:0] MEM_BASE = 32'h00000000;

  function automatic logic [31:0] addr_to_idx(input logic [31:0] addr);
    return (addr - MEM_BASE) >> 2;
  endfunction

  // --- Instruction memory: combinational read ---
  assign imem_resp_data = mem[addr_to_idx(fetch_pc)];

  // --- Data memory: 1-cycle latency ---
  logic        dmem_pending;
  logic [31:0] dmem_read_data;

  assign dmem_req_ready = 1'b1;  // Always ready

  always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
      dmem_resp_valid <= 1'b0;
      dmem_read_data  <= 32'b0;
      dmem_pending    <= 1'b0;
    end else begin
      dmem_pending    <= 1'b0;
      dmem_resp_valid <= 1'b0;

      if (dmem_req_valid) begin
        if (dmem_req_we) begin
          // Store
          mem[addr_to_idx(dmem_req_addr)] <= dmem_req_data;
        end else begin
          // Load: respond next cycle
          dmem_read_data  <= mem[addr_to_idx(dmem_req_addr)];
          dmem_pending    <= 1'b1;
        end
      end

      if (dmem_pending) begin
        dmem_resp_valid <= 1'b1;
      end
    end
  end

  assign dmem_resp_data = dmem_read_data;

  // =========================================================================
  // HTIF: tohost termination
  // =========================================================================
  logic        test_done;
  logic        test_pass;
  logic [31:0] test_code;

  always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
      test_done <= 1'b0;
      test_pass <= 1'b0;
      test_code <= 32'b0;
    end else begin
      if (dmem_req_valid && dmem_req_we &&
          dmem_req_addr == TOHOST_ADDR) begin
        test_done <= 1'b1;
        test_code <= dmem_req_data;
        test_pass <= (dmem_req_data == 32'h1);
      end
    end
  end

  // =========================================================================
  // Cycle counter
  // =========================================================================
  logic [31:0] cycle_count;

  always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
      cycle_count <= 32'b0;
    end else begin
      cycle_count <= cycle_count + 1;
    end
  end

  // =========================================================================
  // Debug trace (enable with +define+TRACE_PIPELINE)
  // =========================================================================
  `ifdef TRACE_PIPELINE
  always_ff @(posedge clk) begin
    if (!reset) begin
      $display("[%0d] PC=0x%08x stall=%b rob_empty=%b",
               cycle_count, fetch_pc, global_stall_out, rob_empty);
    end
  end
  `endif

  // =========================================================================
  // Output assignments
  // =========================================================================
  assign o_test_done       = test_done;
  assign o_test_pass       = test_pass;
  assign o_test_code       = test_code;
  assign o_fetch_pc       = fetch_pc;
  assign o_rob_empty       = rob_empty;
  assign o_global_stall    = global_stall_out;
  assign o_cycle_count     = cycle_count;
  assign o_dmem_req_valid = dmem_req_valid;
  assign o_dmem_req_we    = dmem_req_we;
  assign o_dmem_req_addr  = dmem_req_addr;
  assign o_dmem_req_data  = dmem_req_data;

endmodule
