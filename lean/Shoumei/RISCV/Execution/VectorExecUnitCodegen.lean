/-
RISCV/Execution/VectorExecUnitCodegen.lean - Codegen for Vector Execution Unit

Generates two SystemVerilog files required by the RvvCore integration:

1. rvv_pkg.sv — Compilation-unit package that pulls in all RVV type headers.
   Must be compiled before any other RVV source file.

2. RvvCoreWrapper.sv — Flat-port wrapper around the external RvvCore module
   (from third_party/coralnpu). Replaces all packed struct/array ports with
   plain logic ports so Lean's gate-level CPU can connect to it via
   CircuitInstance port maps.
-/

import Shoumei.RISCV.Execution.VectorExecUnit
import Shoumei.DSL

namespace Shoumei.RISCV.Execution

open Shoumei

/-- Port names for the RvvCore instance in CPU.lean.
    These match the RvvCore.sv module interface. -/
def rvvCoreModuleName : String := "RvvCore"

/-- Number of lanes (N parameter). Lanes 1-3 are tied off. -/
def rvvCoreLanes : Nat := 4

/-- RVVInstruction width: 32-bit PC + 2-bit opcode + 25-bit instruction bits = 59 bits -/
def rvvInstructionWidth : Nat := 59

/-- Number of LSU ports on RvvCore. Slot 0 is used, slot 1 is tied off. -/
def rvvNumLsu : Nat := 2

/-- Generate rvv_pkg.sv content.
    This file pulls in all RVV defines and type headers for the compilation unit.
    It must be compiled before any other RVV source files. -/
def generateRvvPkg : String :=
  "// Auto-generated by Shoumei RTL — do not edit\n" ++
  "// Pull in all RVV defines and types for the compilation unit.\n" ++
  "// Must be compiled before any other RVV source files.\n" ++
  "`include \"rvv_backend_define.svh\"\n" ++
  "`include \"rvv_backend_config.svh\"\n" ++
  "`include \"rvv_backend.svh\"\n" ++
  "`include \"rvv_backend_alu.svh\"\n" ++
  "`include \"rvv_backend_dispatch.svh\"\n" ++
  "`include \"rvv_backend_div.svh\"\n" ++
  "`include \"rvv_backend_pmtrdt.svh\"\n"

/-- Generate a flat-port list entry. -/
private def port (dir width name : String) : String :=
  s!"  {dir} logic {width}{name}"

/-- Generate RvvCoreWrapper.sv content.
    Flat-port wrapper around the external RvvCore module. Replaces all packed
    struct/array ports with plain logic ports for Lean's gate-level integration.

    Parameters:
    - N = 4 lanes (lanes 1-3 tied off by CPU.lean)
    - NUM_LSU = 2 (slot 0 used, slot 1 tied off by CPU.lean)
    - VRegDataT = 128 bits, RegAddrT = 5 bits, MaskT = 16 bits -/
def generateRvvCoreWrapper : String :=
  let n := rvvCoreLanes
  let numLsu := rvvNumLsu
  -- Helper to generate indexed port lines for arrays
  let flatPorts (dir : String) (w : String) (base : String) (count : Nat) : String :=
    String.intercalate ",\n" <|
      (List.range count).map fun i => port dir w s!"{base}_{i}"
  -- Helper for comma-join
  let j (lines : List String) : String := String.intercalate ",\n" lines
  "// Auto-generated by Shoumei RTL — do not edit\n" ++
  "// Flat-port wrapper for RvvCore.\n" ++
  "// Replaces all packed struct/array ports with plain logic ports.\n\n" ++
  "`include \"rvv_backend.svh\"\n\n" ++
  "module RvvCoreWrapper (\n" ++
  j [
    port "input " "" "clk",
    port "input " "" "rstn",
    "\n  // Vector CSR inputs",
    port "input " "[6:0]  " "vstart",
    port "input " "[1:0]  " "vxrm",
    port "input " "" "vxsat",
    port "input " "[2:0]  " "frm",
    s!"\n  // Instruction input (N={n} lanes)",
    port "input " s!"[{n-1}:0]  " "inst_valid",
    "  // Lane 0: flat struct fields",
    port "input " "[31:0] " "inst_data_0_pc",
    port "input " "[1:0]  " "inst_data_0_opcode",
    port "input " "[24:0] " "inst_data_0_bits",
    "  // Lanes 1-3: flat 59-bit packed vectors",
    (String.intercalate ",\n" <|
      (List.range (n-1)).map fun i => port "input " "[58:0] " s!"inst_data_{i+1}"),
    port "output" s!"[{n-1}:0]  " "inst_ready",
    s!"\n  // Register file read (2*N = {2*n} ports)",
    port "input " s!"[{2*n-1}:0]  " "reg_read_valid",
    flatPorts "input " "[31:0] " "reg_read_data" (2*n),
    s!"\n  // Floating point register file read (N={n} ports)",
    flatPorts "input " "[31:0] " "freg_read_data" n,
    s!"\n  // Scalar regfile writeback (configuration, N={n})",
    port "output" s!"[{n-1}:0]  " "reg_write_valid",
    flatPorts "output" "[4:0]  " "reg_write_addr" n,
    flatPorts "output" "[31:0] " "reg_write_data" n,
    "\n  // Scalar regfile writeback (async, non-configuration)",
    port "output" "" "async_rd_valid",
    port "output" "[4:0]  " "async_rd_addr",
    port "output" "[31:0] " "async_rd_data",
    port "input " "" "async_rd_ready",
    "\n  // Floating point regfile writeback (async)",
    port "output" "" "async_frd_valid",
    port "output" "[4:0]  " "async_frd_addr",
    port "output" "[31:0] " "async_frd_data",
    port "input " "" "async_frd_ready",
    s!"\n  // RVV to LSU (NUM_LSU={numLsu})",
    port "output" s!"[{numLsu-1}:0]   " "uop_lsu_valid_rvv2lsu",
    port "output" s!"[{numLsu-1}:0]   " "uop_lsu_idx_valid_rvv2lsu",
    flatPorts "output" "[4:0]   " "uop_lsu_idx_addr_rvv2lsu" numLsu,
    flatPorts "output" "[127:0] " "uop_lsu_idx_data_rvv2lsu" numLsu,
    port "output" s!"[{numLsu-1}:0]   " "uop_lsu_vregfile_valid_rvv2lsu",
    flatPorts "output" "[4:0]   " "uop_lsu_vregfile_addr_rvv2lsu" numLsu,
    flatPorts "output" "[127:0] " "uop_lsu_vregfile_data_rvv2lsu" numLsu,
    port "output" s!"[{numLsu-1}:0]   " "uop_lsu_v0_valid_rvv2lsu",
    flatPorts "output" "[15:0]  " "uop_lsu_v0_data_rvv2lsu" numLsu,
    port "input " s!"[{numLsu-1}:0]   " "uop_lsu_ready_lsu2rvv",
    s!"\n  // LSU to RVV (NUM_LSU={numLsu})",
    port "input " s!"[{numLsu-1}:0]   " "uop_lsu_valid_lsu2rvv",
    flatPorts "input " "[4:0]   " "uop_lsu_addr_lsu2rvv" numLsu,
    flatPorts "input " "[127:0] " "uop_lsu_wdata_lsu2rvv" numLsu,
    port "input " s!"[{numLsu-1}:0]   " "uop_lsu_last_lsu2rvv",
    port "output" s!"[{numLsu-1}:0]   " "uop_lsu_ready_rvv2lsu",
    "\n  // Vector CSR writeback",
    port "output" "" "vcsr_valid",
    port "input " "" "vcsr_ready",
    "\n  // Config state output (flat fields for CPU)",
    port "output" "" "config_state_valid",
    port "output" "[31:0]  " "config_state_vl",
    port "output" "[31:0]  " "config_state_vtype",
    "\n  // Idle / capacity",
    port "output" "" "rvv_idle",
    port "output" "[3:0]   " "queue_capacity",
    "\n  // Trap",
    port "output" "" "trap_valid_o",
    "\n  // VXSAT update",
    port "output" "" "wr_vxsat_valid_o",
    port "output" "" "wr_vxsat_o"
  ] ++ "\n);\n\n" ++
  -- Internal packing/unpacking logic
  "  // ---------------------------------------------------------------\n" ++
  "  // Pack flat ports into RvvCore's typed ports\n" ++
  "  // ---------------------------------------------------------------\n\n" ++
  -- Instruction data packing
  "  // Instruction data: RVVInstruction is packed {pc[31:0], opcode[1:0], bits[24:0]}\n" ++
  s!"  RVVInstruction [{n-1}:0] inst_data_packed;\n" ++
  "  always_comb begin\n" ++
  "    inst_data_packed[0].pc     = inst_data_0_pc;\n" ++
  "    inst_data_packed[0].opcode = RVVOpCode'(inst_data_0_opcode);\n" ++
  "    inst_data_packed[0].bits   = inst_data_0_bits;\n" ++
  (String.intercalate "" <| (List.range (n-1)).map fun i =>
    s!"    inst_data_packed[{i+1}]        = inst_data_{i+1};\n") ++
  "  end\n\n" ++
  -- Register read data packing
  s!"  // Register read data: pack {2*n} flat ports into array\n" ++
  s!"  logic [31:0] reg_read_data_packed [{2*n-1}:0];\n" ++
  (String.intercalate "" <| (List.range (2*n)).map fun i =>
    s!"  assign reg_read_data_packed[{i}] = reg_read_data_{i};\n") ++
  "\n" ++
  -- FP register read data packing
  s!"  // Floating point register read data: pack {n} flat ports into array\n" ++
  s!"  logic [31:0] freg_read_data_packed [{n-1}:0];\n" ++
  (String.intercalate "" <| (List.range n).map fun i =>
    s!"  assign freg_read_data_packed[{i}] = freg_read_data_{i};\n") ++
  "\n" ++
  -- Register write unpacking
  s!"  // Register write: unpack arrays from RvvCore outputs\n" ++
  s!"  logic [4:0]  reg_write_addr_packed [{n-1}:0];\n" ++
  s!"  logic [31:0] reg_write_data_packed [{n-1}:0];\n" ++
  (String.intercalate "" <| (List.range n).map fun i =>
    s!"  assign reg_write_addr_{i} = reg_write_addr_packed[{i}];\n") ++
  (String.intercalate "" <| (List.range n).map fun i =>
    s!"  assign reg_write_data_{i} = reg_write_data_packed[{i}];\n") ++
  "\n" ++
  -- LSU to RVV packing
  s!"  // LSU to RVV: pack flat ports into arrays\n" ++
  s!"  logic [4:0]   uop_lsu_addr_lsu2rvv_packed [{numLsu-1}:0];\n" ++
  s!"  logic [127:0] uop_lsu_wdata_lsu2rvv_packed [{numLsu-1}:0];\n" ++
  (String.intercalate "" <| (List.range numLsu).map fun i =>
    s!"  assign uop_lsu_addr_lsu2rvv_packed[{i}]  = uop_lsu_addr_lsu2rvv_{i};\n") ++
  (String.intercalate "" <| (List.range numLsu).map fun i =>
    s!"  assign uop_lsu_wdata_lsu2rvv_packed[{i}] = uop_lsu_wdata_lsu2rvv_{i};\n") ++
  "\n" ++
  -- RVV to LSU unpacking
  s!"  // RVV to LSU: unpack arrays from RvvCore outputs\n" ++
  s!"  logic [4:0]   uop_lsu_idx_addr_rvv2lsu_packed [{numLsu-1}:0];\n" ++
  s!"  logic [127:0] uop_lsu_idx_data_rvv2lsu_packed [{numLsu-1}:0];\n" ++
  s!"  logic [4:0]   uop_lsu_vregfile_addr_rvv2lsu_packed [{numLsu-1}:0];\n" ++
  s!"  logic [127:0] uop_lsu_vregfile_data_rvv2lsu_packed [{numLsu-1}:0];\n" ++
  s!"  logic [15:0]  uop_lsu_v0_data_rvv2lsu_packed [{numLsu-1}:0];\n\n" ++
  (String.intercalate "" <| (List.range numLsu).map fun i =>
    s!"  assign uop_lsu_idx_addr_rvv2lsu_{i}      = uop_lsu_idx_addr_rvv2lsu_packed[{i}];\n" ++
    s!"  assign uop_lsu_idx_data_rvv2lsu_{i}      = uop_lsu_idx_data_rvv2lsu_packed[{i}];\n" ++
    s!"  assign uop_lsu_vregfile_addr_rvv2lsu_{i} = uop_lsu_vregfile_addr_rvv2lsu_packed[{i}];\n" ++
    s!"  assign uop_lsu_vregfile_data_rvv2lsu_{i} = uop_lsu_vregfile_data_rvv2lsu_packed[{i}];\n" ++
    s!"  assign uop_lsu_v0_data_rvv2lsu_{i}       = uop_lsu_v0_data_rvv2lsu_packed[{i}];\n") ++
  "\n" ++
  -- Config state and vector CSR
  "  // Config state and vector CSR: internal packed structs\n" ++
  "  RVVConfigState config_state_internal;\n" ++
  "  RVVConfigState vector_csr_internal;\n\n" ++
  "  // Extract vl and vtype fields from config_state, zero-extended to 32 bits\n" ++
  "  assign config_state_vl    = {24'b0, config_state_internal.vl};\n" ++
  "  assign config_state_vtype = {24'b0,\n" ++
  "                               config_state_internal.vill,\n" ++
  "                               config_state_internal.ma,\n" ++
  "                               config_state_internal.ta,\n" ++
  "                               config_state_internal.sew,\n" ++
  "                               config_state_internal.lmul};\n\n" ++
  "  // Trap data output (unused by CPU portmap, just expose valid)\n" ++
  "  RVVInstruction trap_data_internal;\n\n" ++
  "  // ROB2RT output (unused by CPU portmap)\n" ++
  "  ROB2RT_t [`NUM_RT_UOP-1:0] rd_rob2rt_unused;\n\n" ++
  -- RvvCore instantiation
  "  // ---------------------------------------------------------------\n" ++
  "  // RvvCore instantiation\n" ++
  "  // ---------------------------------------------------------------\n" ++
  "  RvvCore #(\n" ++
  s!"    .N({n}),\n" ++
  "    .RegDataT(logic [31:0]),\n" ++
  "    .VRegDataT(logic [127:0]),\n" ++
  "    .RegAddrT(logic [4:0]),\n" ++
  "    .MaskT(logic [15:0])\n" ++
  "  ) u_rvv_core (\n" ++
  "    .clk                        (clk),\n" ++
  "    .rstn                       (rstn),\n\n" ++
  "    .vstart                     (vstart),\n" ++
  "    .vxrm                       (vxrm),\n" ++
  "    .vxsat                      (vxsat),\n" ++
  "    .frm                        (frm),\n\n" ++
  "    .inst_valid                 (inst_valid),\n" ++
  "    .inst_data                  (inst_data_packed),\n" ++
  "    .inst_ready                 (inst_ready),\n\n" ++
  "    .reg_read_valid             (reg_read_valid),\n" ++
  -- Pack reg_read_data array into concatenation
  "    .reg_read_data              ({" ++
  String.intercalate ", " ((List.range (2*n)).reverse.map fun i =>
    s!"reg_read_data_packed[{i}]") ++
  "}),\n\n" ++
  "    .freg_read_data             ({" ++
  String.intercalate ", " ((List.range n).reverse.map fun i =>
    s!"freg_read_data_packed[{i}]") ++
  "}),\n\n" ++
  "    .reg_write_valid            (reg_write_valid),\n" ++
  "    .reg_write_addr             ({" ++
  String.intercalate ", " ((List.range n).reverse.map fun i =>
    s!"reg_write_addr_packed[{i}]") ++
  "}),\n" ++
  "    .reg_write_data             ({" ++
  String.intercalate ", " ((List.range n).reverse.map fun i =>
    s!"reg_write_data_packed[{i}]") ++
  "}),\n\n" ++
  "    .async_rd_valid             (async_rd_valid),\n" ++
  "    .async_rd_addr              (async_rd_addr),\n" ++
  "    .async_rd_data              (async_rd_data),\n" ++
  "    .async_rd_ready             (async_rd_ready),\n\n" ++
  "    .async_frd_valid            (async_frd_valid),\n" ++
  "    .async_frd_addr             (async_frd_addr),\n" ++
  "    .async_frd_data             (async_frd_data),\n" ++
  "    .async_frd_ready            (async_frd_ready),\n\n" ++
  "    .uop_lsu_valid_rvv2lsu      (uop_lsu_valid_rvv2lsu),\n" ++
  "    .uop_lsu_idx_valid_rvv2lsu  (uop_lsu_idx_valid_rvv2lsu),\n" ++
  "    .uop_lsu_idx_addr_rvv2lsu   ({" ++
  String.intercalate ", " ((List.range numLsu).reverse.map fun i =>
    s!"uop_lsu_idx_addr_rvv2lsu_packed[{i}]") ++
  "}),\n" ++
  "    .uop_lsu_idx_data_rvv2lsu   ({" ++
  String.intercalate ", " ((List.range numLsu).reverse.map fun i =>
    s!"uop_lsu_idx_data_rvv2lsu_packed[{i}]") ++
  "}),\n" ++
  "    .uop_lsu_vregfile_valid_rvv2lsu (uop_lsu_vregfile_valid_rvv2lsu),\n" ++
  "    .uop_lsu_vregfile_addr_rvv2lsu  ({" ++
  String.intercalate ", " ((List.range numLsu).reverse.map fun i =>
    s!"uop_lsu_vregfile_addr_rvv2lsu_packed[{i}]") ++
  "}),\n" ++
  "    .uop_lsu_vregfile_data_rvv2lsu  ({" ++
  String.intercalate ", " ((List.range numLsu).reverse.map fun i =>
    s!"uop_lsu_vregfile_data_rvv2lsu_packed[{i}]") ++
  "}),\n" ++
  "    .uop_lsu_v0_valid_rvv2lsu   (uop_lsu_v0_valid_rvv2lsu),\n" ++
  "    .uop_lsu_v0_data_rvv2lsu    ({" ++
  String.intercalate ", " ((List.range numLsu).reverse.map fun i =>
    s!"uop_lsu_v0_data_rvv2lsu_packed[{i}]") ++
  "}),\n" ++
  "    .uop_lsu_ready_lsu2rvv      (uop_lsu_ready_lsu2rvv),\n\n" ++
  "    .uop_lsu_valid_lsu2rvv      (uop_lsu_valid_lsu2rvv),\n" ++
  "    .uop_lsu_addr_lsu2rvv       ({" ++
  String.intercalate ", " ((List.range numLsu).reverse.map fun i =>
    s!"uop_lsu_addr_lsu2rvv_packed[{i}]") ++
  "}),\n" ++
  "    .uop_lsu_wdata_lsu2rvv      ({" ++
  String.intercalate ", " ((List.range numLsu).reverse.map fun i =>
    s!"uop_lsu_wdata_lsu2rvv_packed[{i}]") ++
  "}),\n" ++
  "    .uop_lsu_last_lsu2rvv       (uop_lsu_last_lsu2rvv),\n" ++
  "    .uop_lsu_ready_rvv2lsu      (uop_lsu_ready_rvv2lsu),\n\n" ++
  "    .vcsr_valid                 (vcsr_valid),\n" ++
  "    .vector_csr                 (vector_csr_internal),\n" ++
  "    .vcsr_ready                 (vcsr_ready),\n\n" ++
  "    .config_state_valid         (config_state_valid),\n" ++
  "    .config_state               (config_state_internal),\n\n" ++
  "    .rvv_idle                   (rvv_idle),\n" ++
  "    .queue_capacity             (queue_capacity),\n\n" ++
  "    .rd_rob2rt_o                (rd_rob2rt_unused),\n\n" ++
  "    .trap_valid_o               (trap_valid_o),\n" ++
  "    .trap_data_o                (trap_data_internal),\n\n" ++
  "    .wr_vxsat_valid_o           (wr_vxsat_valid_o),\n" ++
  "    .wr_vxsat_o                 (wr_vxsat_o)\n" ++
  "  );\n\n" ++
  "endmodule\n"

/-- Write both RVV integration files to the given output directory. -/
def writeRvvIntegrationFiles (svDir : String) : IO Unit := do
  let pkgPath := s!"{svDir}/rvv_pkg.sv"
  let wrapperPath := s!"{svDir}/RvvCoreWrapper.sv"
  IO.FS.writeFile pkgPath generateRvvPkg
  IO.FS.writeFile wrapperPath generateRvvCoreWrapper
  IO.println s!"  ✓ {pkgPath}"
  IO.println s!"  ✓ {wrapperPath}"

end Shoumei.RISCV.Execution
