# Codegen V2: Signal Naming & Output Modes

Draft sketches for the three code generation targets.
Feedback welcome -- nothing here is implemented yet.

---

## Running Example: Queue1_32

A 1-entry, 32-bit decoupled FIFO queue.

**Ports:**
- `enq` (Decoupled sink): `enq.bits[31:0]`, `enq.valid`, `enq.ready`
- `deq` (Decoupled source): `deq.bits[31:0]`, `deq.valid`, `deq.ready`
- `clock`, `reset`

**Internals:**
- `data_reg[31:0]` -- 32 DFFs storing the data
- `valid_reg` -- 1 DFF tracking occupancy
- `enq_fire`, `deq_fire` -- handshake fires
- `valid_next`, `data_next[31:0]` -- next-state logic

---

## Current Output (for reference)

What the codegen produces today:

### Current SV

```systemverilog
module Queue1_32(enq_data_0, enq_data_1, ..., enq_data_31,
                 enq_valid, deq_ready, clock, reset,
                 enq_ready, data_reg_0, ..., data_reg_31, valid);
  input enq_data_0, enq_data_1, ..., enq_data_31;
  input enq_valid, deq_ready, clock, reset;
  output enq_ready;
  output reg data_reg_0, data_reg_1, ..., data_reg_31;
  output reg valid;

  wire enq_fire;
  wire deq_fire;
  wire not_deq_fire;
  wire valid_hold;
  wire valid_next;
  wire [31:0] data_next;

  assign enq_ready = ~valid;
  assign enq_fire = enq_valid & enq_ready;
  assign deq_fire = valid & deq_ready;
  assign not_deq_fire = ~deq_fire;
  assign valid_hold = valid & not_deq_fire;
  assign valid_next = enq_fire | valid_hold;
  assign data_next[0] = enq_fire ? enq_data_0 : data_reg_0;
  assign data_next[1] = enq_fire ? enq_data_1 : data_reg_1;
  // ... 30 more lines ...

  always @(posedge clock or posedge reset) begin
    if (reset) valid <= 1'b0;
    else       valid <= valid_next;
  end
  always @(posedge clock or posedge reset) begin
    if (reset) data_reg_0 <= 1'b0;
    else       data_reg_0 <= data_next_0;
  end
  // ... 31 more always blocks ...
endmodule
```

**Problems:**
1. Port names leak internal structure (`data_reg_0` instead of `deq_bits_0`)
2. Every bit is a separate port -- no buses
3. 32 individual `always` blocks instead of one
4. No struct grouping for the decoupled interface
5. When >200 ports: collapses to `inputs_0`, `inputs_1` ... total loss of semantics

### Current Chisel

```scala
class Queue1_32 extends RawModule {
  val clock = IO(Input(Clock()))
  val reset = IO(Input(AsyncReset()))
  val enq_data_0 = IO(Input(Bool()))
  val enq_data_1 = IO(Input(Bool()))
  // ... 30 more Bool inputs ...
  val enq_valid = IO(Input(Bool()))
  val deq_ready = IO(Input(Bool()))
  val enq_ready = IO(Output(Bool()))
  val data_reg_0 = IO(Output(Bool()))
  // ... 31 more Bool outputs ...
  val valid = IO(Output(Bool()))

  val data_reg_0_reg = withClockAndReset(clock, reset) { RegInit(false.B) }
  // ... 32 RegInit declarations ...

  val enq_fire = Wire(Bool())
  enq_fire := enq_valid & enq_ready
  // ... gate-by-gate assignments ...
}
```

**Problems:**
1. Everything is `Bool()` -- no `UInt`, no `Vec`, no `Bundle`
2. Individual `RegInit(false.B)` per bit
3. Chisel's type system is completely wasted

---

## Proposed: Mode 1 -- SV Netlist (Flat)

Everything flattened to primitives. No module hierarchy.
Signal names carry **full hierarchical path** so you know where each wire came from.

Use case: formal tools, ABC, equivalence checking, gate-level simulation.

```systemverilog
// Auto-generated by Shoumei -- netlist mode (flat)
// Source: Queue1_32
module Queue1_32(
  input  logic        clock,
  input  logic        reset,
  // -- enqueue interface --
  input  logic [31:0] enq_bits,
  input  logic        enq_valid,
  output logic        enq_ready,
  // -- dequeue interface --
  output logic [31:0] deq_bits,
  output logic        deq_valid,
  output logic        deq_ready   // note: deq_ready is an input in decoupled,
                                  // but the port direction is set by the protocol
);

  // === internal wires (hierarchical names from flattening) ===
  logic        ctrl__enq_fire;
  logic        ctrl__deq_fire;
  logic        ctrl__not_deq_fire;
  logic        ctrl__valid_hold;

  // === next-state ===
  logic        valid_next;
  logic [31:0] data_next;

  // === state (registers) ===
  logic        valid_reg;
  logic [31:0] data_reg;

  // === control logic ===
  assign enq_ready           = ~valid_reg;
  assign ctrl__enq_fire      = enq_valid & enq_ready;
  assign ctrl__deq_fire      = valid_reg & deq_ready;
  assign ctrl__not_deq_fire  = ~ctrl__deq_fire;
  assign ctrl__valid_hold    = valid_reg & ctrl__not_deq_fire;
  assign valid_next          = ctrl__enq_fire | ctrl__valid_hold;

  // === datapath mux (vectorized) ===
  assign data_next = ctrl__enq_fire ? enq_bits : data_reg;

  // === sequential elements ===
  always_ff @(posedge clock or posedge reset) begin
    if (reset) begin
      valid_reg <= 1'b0;
      data_reg  <= 32'b0;
    end else begin
      valid_reg <= valid_next;
      data_reg  <= data_next;
    end
  end

  // === output assignments ===
  assign deq_bits  = data_reg;
  assign deq_valid = valid_reg;

endmodule
```

**What changed vs. current:**
| Aspect | Current | Proposed |
|--------|---------|----------|
| Port style | `enq_data_0, enq_data_1, ...` (1 bit each) | `enq_bits [31:0]` (bus) |
| Port names | Leak internal names (`data_reg_0`) | Semantic interface names (`deq_bits`) |
| Internal wires | `enq_fire` | `ctrl__enq_fire` (hierarchy prefix) |
| DFF blocks | One `always` per bit | One `always_ff` block, vectorized |
| Bus detection | Heuristic (name suffix parsing) | Type-driven from DSL |
| SV style | Verilog-95 | SystemVerilog (logic, always_ff) |
| Bundled I/O hack | `inputs_0` for >200 ports | Never needed -- buses handle it |

**Hierarchical name convention for netlist mode:**
When a hierarchical module is flattened, internal wires get prefixed:
```
u_regfile__read_port__data[31:0]     -- from instance u_regfile, sub-block read_port
u_queue__ctrl__enq_fire              -- from instance u_queue, control section
```
Double underscore `__` separates hierarchy levels (single `_` stays in signal names).

---

## Proposed: Mode 2 -- SV Hierarchical

Like a human would write it. Module instantiation, SV structs for interfaces.

Use case: synthesis, readable RTL, waveform debugging.

### Struct Definitions (shared header or per-package)

```systemverilog
// Auto-generated by Shoumei -- interface definitions
// File: shoumei_interfaces.svh (or package)

typedef struct packed {
  logic [31:0] bits;
  logic        valid;
  logic        ready;
} decoupled32_t;

// Other commonly-used structs
typedef struct packed {
  logic [31:0] addr;
  logic [31:0] data;
  logic [1:0]  size;
} mem_req_t;

typedef struct packed {
  logic [5:0]  phys_rd;
  logic [4:0]  arch_rd;
  logic        valid;
} rename_entry_t;
```

### Module Output

```systemverilog
// Auto-generated by Shoumei -- hierarchical mode
// Source: Queue1_32
module Queue1_32(
  input  logic           clock,
  input  logic           reset,
  // -- enqueue (sink) --
  input  logic [31:0]    enq_bits,
  input  logic           enq_valid,
  output logic           enq_ready,
  // -- dequeue (source) --
  output logic [31:0]    deq_bits,
  output logic           deq_valid,
  input  logic           deq_ready
);

  // --- state ---
  logic        valid_reg;
  logic [31:0] data_reg;

  // --- control ---
  logic enq_fire, deq_fire;

  assign enq_ready = ~valid_reg;
  assign enq_fire  = enq_valid & enq_ready;
  assign deq_fire  = deq_valid & deq_ready;

  // --- next-state ---
  logic        valid_next;
  logic [31:0] data_next;

  assign valid_next = enq_fire | (valid_reg & ~deq_fire);
  assign data_next  = enq_fire ? enq_bits : data_reg;

  // --- flops ---
  always_ff @(posedge clock or posedge reset) begin
    if (reset) begin
      valid_reg <= 1'b0;
      data_reg  <= '0;
    end else begin
      valid_reg <= valid_next;
      data_reg  <= data_next;
    end
  end

  // --- outputs ---
  assign deq_bits  = data_reg;
  assign deq_valid = valid_reg;

endmodule
```

### Hierarchical Example: Queue4_32 (4-entry Queue)

Shows real module instantiation with struct-typed ports.

```systemverilog
module Queue4_32(
  input  logic           clock,
  input  logic           reset,
  input  logic [31:0]    enq_bits,
  input  logic           enq_valid,
  output logic           enq_ready,
  output logic [31:0]    deq_bits,
  output logic           deq_valid,
  input  logic           deq_ready
);

  // --- pointer / count state ---
  logic [1:0] head_ptr, tail_ptr;
  logic [2:0] count;
  logic       full, empty;

  assign full  = (count == 3'd4);
  assign empty = (count == 3'd0);

  // --- storage: 4 x 32-bit register bank ---
  logic [31:0] mem [0:3];

  // --- control ---
  logic enq_fire, deq_fire;

  assign enq_ready = ~full;
  assign enq_fire  = enq_valid & enq_ready;
  assign deq_valid = ~empty;
  assign deq_fire  = deq_valid & deq_ready;

  // --- pointer update ---
  always_ff @(posedge clock or posedge reset) begin
    if (reset) begin
      head_ptr <= '0;
      tail_ptr <= '0;
      count    <= '0;
    end else begin
      if (enq_fire) tail_ptr <= tail_ptr + 1'b1;
      if (deq_fire) head_ptr <= head_ptr + 1'b1;
      case ({enq_fire, deq_fire})
        2'b10:   count <= count + 1'b1;
        2'b01:   count <= count - 1'b1;
        default: count <= count;   // 2'b00 or 2'b11
      endcase
    end
  end

  // --- memory write ---
  always_ff @(posedge clock) begin
    if (enq_fire)
      mem[tail_ptr] <= enq_bits;
  end

  // --- memory read ---
  assign deq_bits = mem[head_ptr];

endmodule
```

### Bigger Hierarchical Example: ReservationStation

Shows struct ports + submodule instantiation.

```systemverilog
module ReservationStation4(
  input  logic            clock,
  input  logic            reset,
  // -- dispatch (write) --
  input  rs_entry_t       dispatch_data,
  input  logic            dispatch_valid,
  output logic            dispatch_ready,
  // -- issue (read, oldest-ready) --
  output rs_entry_t       issue_data,
  output logic            issue_valid,
  input  logic            issue_ready,
  // -- CDB broadcast (wake-up) --
  input  cdb_entry_t      cdb          [0:3],
  input  logic [3:0]      cdb_valid,
  // -- flush --
  input  logic            flush
);

  // --- entry storage ---
  rs_entry_t  entries [0:3];
  logic [3:0] entry_valid;
  logic [3:0] entry_ready;   // src1_ready & src2_ready

  // --- submodule: age-based priority picker ---
  PriorityPicker4 u_picker(
    .valid     (entry_valid & entry_ready),
    .grant     (issue_grant)
  );

  // --- submodule: CAM for wakeup matching ---
  genvar i;
  generate
    for (i = 0; i < 4; i++) begin : gen_wakeup
      WakeupLogic u_wakeup(
        .entry     (entries[i]),
        .cdb       (cdb),
        .cdb_valid (cdb_valid),
        .wakeup    (wakeup[i])
      );
    end
  endgenerate

  // ...
endmodule
```

---

## Proposed: Mode 3 -- Chisel Hierarchical

Proper Chisel idioms: `Bundle`, `Decoupled`, `Vec`, `UInt`.

### Bundle Definitions (shared file)

```scala
// Auto-generated by Shoumei -- Chisel bundles
// File: generated/Interfaces.scala
package generated

import chisel3._
import chisel3.util._

/** Rename mapping entry */
class RenameEntry extends Bundle {
  val physRd = UInt(6.W)
  val archRd = UInt(5.W)
  val valid  = Bool()
}

/** Memory request */
class MemReq extends Bundle {
  val addr = UInt(32.W)
  val data = UInt(32.W)
  val size = UInt(2.W)
}

/** CDB broadcast entry */
class CDBEntry extends Bundle {
  val tag  = UInt(6.W)
  val data = UInt(32.W)
}
```

### Module Output: Queue1_32

```scala
// Auto-generated by Shoumei -- Chisel hierarchical mode
// Source: Queue1_32
package generated

import chisel3._
import chisel3.util._

class Queue1_32 extends Module {
  val io = IO(new Bundle {
    val enq = Flipped(Decoupled(UInt(32.W)))
    val deq = Decoupled(UInt(32.W))
  })

  // --- state ---
  val valid_reg = RegInit(false.B)
  val data_reg  = RegInit(0.U(32.W))

  // --- control ---
  val enq_fire = io.enq.valid && io.enq.ready
  val deq_fire = io.deq.valid && io.deq.ready

  io.enq.ready := ~valid_reg
  io.deq.valid := valid_reg

  // --- next-state ---
  val valid_next = enq_fire || (valid_reg && !deq_fire)
  val data_next  = Mux(enq_fire, io.enq.bits, data_reg)

  // --- register update ---
  valid_reg := valid_next
  data_reg  := data_next

  // --- output ---
  io.deq.bits := data_reg
}
```

### Hierarchical Example: Queue4_32

```scala
class Queue4_32 extends Module {
  val io = IO(new Bundle {
    val enq = Flipped(Decoupled(UInt(32.W)))
    val deq = Decoupled(UInt(32.W))
  })

  // --- pointer / count ---
  val head_ptr = RegInit(0.U(2.W))
  val tail_ptr = RegInit(0.U(2.W))
  val count    = RegInit(0.U(3.W))

  val full  = count === 4.U
  val empty = count === 0.U

  // --- storage ---
  val mem = Mem(4, UInt(32.W))

  // --- control ---
  io.enq.ready := !full
  io.deq.valid := !empty

  val enq_fire = io.enq.fire
  val deq_fire = io.deq.fire

  // --- pointer update ---
  when(enq_fire) { tail_ptr := tail_ptr + 1.U }
  when(deq_fire) { head_ptr := head_ptr + 1.U }
  when(enq_fire && !deq_fire) {
    count := count + 1.U
  }.elsewhen(!enq_fire && deq_fire) {
    count := count - 1.U
  }

  // --- memory ---
  when(enq_fire) { mem.write(tail_ptr, io.enq.bits) }
  io.deq.bits := mem.read(head_ptr)
}
```

### Bigger Hierarchical: ReservationStation

```scala
class RSEntry extends Bundle {
  val opcode    = UInt(4.W)
  val src1_tag  = UInt(6.W)
  val src1_data = UInt(32.W)
  val src1_rdy  = Bool()
  val src2_tag  = UInt(6.W)
  val src2_data = UInt(32.W)
  val src2_rdy  = Bool()
  val dst_tag   = UInt(6.W)
}

class ReservationStation4 extends Module {
  val io = IO(new Bundle {
    val dispatch = Flipped(Decoupled(new RSEntry))
    val issue    = Decoupled(new RSEntry)
    val cdb      = Input(Vec(4, Valid(new CDBEntry)))
    val flush    = Input(Bool())
  })

  // --- entry storage ---
  val entries     = Reg(Vec(4, new RSEntry))
  val entry_valid = RegInit(VecInit(Seq.fill(4)(false.B)))
  val entry_ready = Wire(Vec(4, Bool()))

  // --- readiness check ---
  (0 until 4).foreach { i =>
    entry_ready(i) := entries(i).src1_rdy && entries(i).src2_rdy
  }

  // --- age-based picker ---
  val u_picker = Module(new PriorityPicker4)
  u_picker.io.valid := entry_valid.asUInt & entry_ready.asUInt

  // --- CDB wakeup ---
  for (i <- 0 until 4) {
    for (j <- 0 until 4) {
      when(io.cdb(j).valid && !entries(i).src1_rdy &&
           entries(i).src1_tag === io.cdb(j).bits.tag) {
        entries(i).src1_data := io.cdb(j).bits.data
        entries(i).src1_rdy  := true.B
      }
      // same for src2
    }
  }

  // --- dispatch ---
  val free_slot = PriorityEncoder(~entry_valid.asUInt)
  io.dispatch.ready := !entry_valid.asUInt.andR

  when(io.dispatch.fire) {
    entries(free_slot)     := io.dispatch.bits
    entry_valid(free_slot) := true.B
  }

  // --- issue ---
  io.issue.valid := (entry_valid.asUInt & entry_ready.asUInt).orR
  io.issue.bits  := entries(u_picker.io.grant)
  when(io.issue.fire) {
    entry_valid(u_picker.io.grant) := false.B
  }

  // --- flush ---
  when(io.flush) {
    entry_valid := VecInit(Seq.fill(4)(false.B))
  }
}
```

---

## DSL Changes Required

To support the above, the DSL needs type information.

### Option A: Lightweight -- Signal Groups (minimal DSL change)

Add a `SignalGroup` annotation layer on top of existing `Wire`:

```lean
-- Annotation: groups of wires that form a logical signal
structure SignalGroup where
  name     : String
  wires    : List Wire
  width    : Nat            -- bit width (wires.length)
  deriving Repr

-- Annotation: interface bundle (group of groups)
structure InterfaceBundle where
  name     : String
  signals  : List SignalGroup
  protocol : Option String  -- "decoupled", "valid", "none"
  deriving Repr

-- Circuit gets optional annotations (backward compatible)
structure Circuit where
  name      : String
  inputs    : List Wire
  outputs   : List Wire
  gates     : List Gate
  instances : List CircuitInstance
  -- v2 annotations (optional, codegen uses if present)
  signalGroups : List SignalGroup := []
  interfaces   : List InterfaceBundle := []
```

**Pro:** Backward compatible. Existing circuits still work. Annotations are additive.
**Con:** Two sources of truth (wire list + annotations). Can get out of sync.

### Option B: Full -- Typed Wires (bigger DSL change)

```lean
-- Signal types
inductive SignalType where
  | Bool                                        -- 1 bit
  | UInt (width : Nat)                          -- unsigned multi-bit
  | SInt (width : Nat)                          -- signed multi-bit
  | Struct (name : String) (fields : List (String x SignalType))
  | Vec (n : Nat) (elem : SignalType)
  deriving Repr

-- Typed port (replaces Wire for I/O)
structure Port where
  name      : String
  type      : SignalType
  direction : Direction    -- In | Out | Flip (for decoupled)
  deriving Repr

-- Circuit v2
structure Circuit where
  name      : String
  ports     : List Port            -- replaces inputs/outputs
  gates     : List Gate            -- still flat for netlist core
  instances : List CircuitInstance
```

**Pro:** Single source of truth. Type info flows through entire pipeline.
**Con:** Large refactor. Every circuit definition, proof, codegen needs updating.

### Recommendation

**Start with Option A.** Ship the three output modes with annotations.
Migrate to Option B incrementally as the RV32IM build-out demands richer types.

The key insight: the **flat gate list is still the proof core**. The annotations
are for codegen only. This preserves all existing proofs.

---

## Signal Naming Rules

### Port Names

| Current | Proposed | Rationale |
|---------|----------|-----------|
| `enq_data_0` ... `enq_data_31` | `enq_bits[31:0]` | Bus, matches Decoupled convention |
| `data_reg_0` (as output) | `deq_bits[31:0]` | Interface name, not internal name |
| `valid` (as output) | `deq_valid` | Scoped to interface |
| `enq_valid` | `enq_valid` | Already good |
| `deq_ready` | `deq_ready` | Already good |
| `inputs_0` ... `inputs_N` | Never happens | Buses + structs handle any port count |

### Internal Wire Names

| Current | Proposed (hierarchical) | Proposed (netlist) |
|---------|------------------------|-------------------|
| `enq_fire` | `enq_fire` | `ctrl__enq_fire` |
| `data_next_0` | `data_next[0]` | `data_next[0]` |
| `valid_hold` | `valid_hold` | `ctrl__valid_hold` |
| `_wires(42)` | Never happens | Never happens |

### Hierarchy Separator

- Single underscore `_` : within a signal name (`enq_fire`, `data_reg`)
- Double underscore `__` : hierarchy level in netlist mode (`u_queue__ctrl__fire`)
- Dot `.` : SV hierarchical reference in waveforms (`u_queue.ctrl.fire`)

---

## LEC Implications

The current LEC flow compares Lean SV vs. Chisel SV bit-for-bit. With three modes:

| Lean Output | Chisel Output | LEC Method |
|-------------|---------------|------------|
| SV Netlist | -- | Self-consistent (single source) |
| SV Hierarchical | Chisel Hierarchical (via CIRCT) | Existing SEC/SAT flow |
| SV Netlist | SV Hierarchical | Flatten-and-compare (Yosys `flatten`) |

The netlist mode is the "ground truth" for proofs. The hierarchical modes must
be provably equivalent to it. This is easier than the current situation because
both hierarchical modes share the same structure -- only syntax differs.

---

## Open Questions

1. **Struct naming**: Should struct types be auto-derived from `InterfaceBundle`
   names, or manually specified? (e.g., is `decoupled32_t` always the same
   shape, or could two modules define different 32-bit decoupled types?)

2. **Netlist flattening depth**: Should netlist mode flatten *everything*
   (including RAM primitives), or stop at technology primitives?

3. **Multi-bit gate ops**: The current DSL is bit-level (every gate is 1 bit).
   For vectorized `assign data_next = ...` we need to either:
   - Keep bit-level gates but *reconstruct* buses in codegen (pattern matching)
   - Add multi-bit gate types to the DSL (`MUXN`, `ANDN`, etc.)

   Recommendation: reconstruct in codegen. Don't change the proof core.

4. **SV struct vs. interface**: SV `struct packed` is simpler and synthesizable.
   SV `interface` with `modport` is more powerful but tooling support varies.
   Leaning toward `struct packed` only.

5. **Chisel `Decoupled` vs. custom Bundle**: Chisel stdlib `Decoupled` is
   convenient but opinionated (uses `ReadyValidIO`). Custom `Bundle` gives
   more control. Could support both via a flag.
