diff --git a/hdl/verilog/rvv/design/RvvCoreWrapper.sv b/hdl/verilog/rvv/design/RvvCoreWrapper.sv
new file mode 100644
index 0000000..3c9887b
--- /dev/null
+++ b/hdl/verilog/rvv/design/RvvCoreWrapper.sv
@@ -0,0 +1,299 @@
+// Flat-port wrapper for RvvCore.
+// Replaces all packed struct/array ports with plain logic ports.
+
+`include "rvv_backend.svh"
+
+module RvvCoreWrapper (
+  input  logic        clk,
+  input  logic        rstn,
+
+  // Vector CSR inputs
+  input  logic [6:0]  vstart,
+  input  logic [1:0]  vxrm,
+  input  logic        vxsat,
+  input  logic [2:0]  frm,
+
+  // Instruction input (N=4 lanes)
+  input  logic [3:0]  inst_valid,
+  // Lane 0: flat struct fields
+  input  logic [31:0] inst_data_0_pc,
+  input  logic [1:0]  inst_data_0_opcode,
+  input  logic [24:0] inst_data_0_bits,
+  // Lanes 1-3: flat 59-bit packed vectors
+  input  logic [58:0] inst_data_1,
+  input  logic [58:0] inst_data_2,
+  input  logic [58:0] inst_data_3,
+  output logic [3:0]  inst_ready,
+
+  // Register file read (2*N = 8 ports)
+  input  logic [7:0]  reg_read_valid,
+  input  logic [31:0] reg_read_data_0,
+  input  logic [31:0] reg_read_data_1,
+  input  logic [31:0] reg_read_data_2,
+  input  logic [31:0] reg_read_data_3,
+  input  logic [31:0] reg_read_data_4,
+  input  logic [31:0] reg_read_data_5,
+  input  logic [31:0] reg_read_data_6,
+  input  logic [31:0] reg_read_data_7,
+
+  // Floating point register file read (N=4 ports)
+  input  logic [31:0] freg_read_data_0,
+  input  logic [31:0] freg_read_data_1,
+  input  logic [31:0] freg_read_data_2,
+  input  logic [31:0] freg_read_data_3,
+
+  // Scalar regfile writeback (configuration, N=4)
+  output logic [3:0]  reg_write_valid,
+  output logic [4:0]  reg_write_addr_0,
+  output logic [4:0]  reg_write_addr_1,
+  output logic [4:0]  reg_write_addr_2,
+  output logic [4:0]  reg_write_addr_3,
+  output logic [31:0] reg_write_data_0,
+  output logic [31:0] reg_write_data_1,
+  output logic [31:0] reg_write_data_2,
+  output logic [31:0] reg_write_data_3,
+
+  // Scalar regfile writeback (async, non-configuration)
+  output logic        async_rd_valid,
+  output logic [4:0]  async_rd_addr,
+  output logic [31:0] async_rd_data,
+  input  logic        async_rd_ready,
+
+  // Floating point regfile writeback (async)
+  output logic        async_frd_valid,
+  output logic [4:0]  async_frd_addr,
+  output logic [31:0] async_frd_data,
+  input  logic        async_frd_ready,
+
+  // RVV to LSU (NUM_LSU=2)
+  output logic [1:0]   uop_lsu_valid_rvv2lsu,
+  output logic [1:0]   uop_lsu_idx_valid_rvv2lsu,
+  output logic [4:0]   uop_lsu_idx_addr_rvv2lsu_0,
+  output logic [4:0]   uop_lsu_idx_addr_rvv2lsu_1,
+  output logic [127:0] uop_lsu_idx_data_rvv2lsu_0,
+  output logic [127:0] uop_lsu_idx_data_rvv2lsu_1,
+  output logic [1:0]   uop_lsu_vregfile_valid_rvv2lsu,
+  output logic [4:0]   uop_lsu_vregfile_addr_rvv2lsu_0,
+  output logic [4:0]   uop_lsu_vregfile_addr_rvv2lsu_1,
+  output logic [127:0] uop_lsu_vregfile_data_rvv2lsu_0,
+  output logic [127:0] uop_lsu_vregfile_data_rvv2lsu_1,
+  output logic [1:0]   uop_lsu_v0_valid_rvv2lsu,
+  output logic [15:0]  uop_lsu_v0_data_rvv2lsu_0,
+  output logic [15:0]  uop_lsu_v0_data_rvv2lsu_1,
+  input  logic [1:0]   uop_lsu_ready_lsu2rvv,
+
+  // LSU to RVV (NUM_LSU=2)
+  input  logic [1:0]   uop_lsu_valid_lsu2rvv,
+  input  logic [4:0]   uop_lsu_addr_lsu2rvv_0,
+  input  logic [4:0]   uop_lsu_addr_lsu2rvv_1,
+  input  logic [127:0] uop_lsu_wdata_lsu2rvv_0,
+  input  logic [127:0] uop_lsu_wdata_lsu2rvv_1,
+  input  logic [1:0]   uop_lsu_last_lsu2rvv,
+  output logic [1:0]   uop_lsu_ready_rvv2lsu,
+
+  // Vector CSR writeback
+  output logic         vcsr_valid,
+  input  logic         vcsr_ready,
+
+  // Config state output (flat fields for CPU)
+  output logic         config_state_valid,
+  output logic [31:0]  config_state_vl,
+  output logic [31:0]  config_state_vtype,
+
+  // Idle / capacity
+  output logic         rvv_idle,
+  output logic [3:0]   queue_capacity,
+
+  // Trap
+  output logic         trap_valid_o,
+
+  // VXSAT update
+  output logic         wr_vxsat_valid_o,
+  output logic         wr_vxsat_o
+);
+
+  // ---------------------------------------------------------------
+  // Pack flat ports into RvvCore's typed ports
+  // ---------------------------------------------------------------
+
+  // Instruction data: RVVInstruction is packed {pc[31:0], opcode[1:0], bits[24:0]}
+  RVVInstruction [3:0] inst_data_packed;
+  always_comb begin
+    inst_data_packed[0].pc     = inst_data_0_pc;
+    inst_data_packed[0].opcode = RVVOpCode'(inst_data_0_opcode);
+    inst_data_packed[0].bits   = inst_data_0_bits;
+    inst_data_packed[1]        = inst_data_1;
+    inst_data_packed[2]        = inst_data_2;
+    inst_data_packed[3]        = inst_data_3;
+  end
+
+  // Register read data: pack 8 flat ports into array
+  logic [31:0] reg_read_data_packed [7:0];
+  assign reg_read_data_packed[0] = reg_read_data_0;
+  assign reg_read_data_packed[1] = reg_read_data_1;
+  assign reg_read_data_packed[2] = reg_read_data_2;
+  assign reg_read_data_packed[3] = reg_read_data_3;
+  assign reg_read_data_packed[4] = reg_read_data_4;
+  assign reg_read_data_packed[5] = reg_read_data_5;
+  assign reg_read_data_packed[6] = reg_read_data_6;
+  assign reg_read_data_packed[7] = reg_read_data_7;
+
+  // Floating point register read data: pack 4 flat ports into array
+  logic [31:0] freg_read_data_packed [3:0];
+  assign freg_read_data_packed[0] = freg_read_data_0;
+  assign freg_read_data_packed[1] = freg_read_data_1;
+  assign freg_read_data_packed[2] = freg_read_data_2;
+  assign freg_read_data_packed[3] = freg_read_data_3;
+
+  // Register write: unpack arrays from RvvCore outputs
+  logic [4:0]  reg_write_addr_packed [3:0];
+  logic [31:0] reg_write_data_packed [3:0];
+  assign reg_write_addr_0 = reg_write_addr_packed[0];
+  assign reg_write_addr_1 = reg_write_addr_packed[1];
+  assign reg_write_addr_2 = reg_write_addr_packed[2];
+  assign reg_write_addr_3 = reg_write_addr_packed[3];
+  assign reg_write_data_0 = reg_write_data_packed[0];
+  assign reg_write_data_1 = reg_write_data_packed[1];
+  assign reg_write_data_2 = reg_write_data_packed[2];
+  assign reg_write_data_3 = reg_write_data_packed[3];
+
+  // LSU to RVV: pack flat ports into arrays
+  logic [4:0]   uop_lsu_addr_lsu2rvv_packed [1:0];
+  logic [127:0] uop_lsu_wdata_lsu2rvv_packed [1:0];
+  assign uop_lsu_addr_lsu2rvv_packed[0]  = uop_lsu_addr_lsu2rvv_0;
+  assign uop_lsu_addr_lsu2rvv_packed[1]  = uop_lsu_addr_lsu2rvv_1;
+  assign uop_lsu_wdata_lsu2rvv_packed[0] = uop_lsu_wdata_lsu2rvv_0;
+  assign uop_lsu_wdata_lsu2rvv_packed[1] = uop_lsu_wdata_lsu2rvv_1;
+
+  // RVV to LSU: unpack arrays from RvvCore outputs
+  logic [4:0]   uop_lsu_idx_addr_rvv2lsu_packed [1:0];
+  logic [127:0] uop_lsu_idx_data_rvv2lsu_packed [1:0];
+  logic [4:0]   uop_lsu_vregfile_addr_rvv2lsu_packed [1:0];
+  logic [127:0] uop_lsu_vregfile_data_rvv2lsu_packed [1:0];
+  logic [15:0]  uop_lsu_v0_data_rvv2lsu_packed [1:0];
+
+  assign uop_lsu_idx_addr_rvv2lsu_0      = uop_lsu_idx_addr_rvv2lsu_packed[0];
+  assign uop_lsu_idx_addr_rvv2lsu_1      = uop_lsu_idx_addr_rvv2lsu_packed[1];
+  assign uop_lsu_idx_data_rvv2lsu_0      = uop_lsu_idx_data_rvv2lsu_packed[0];
+  assign uop_lsu_idx_data_rvv2lsu_1      = uop_lsu_idx_data_rvv2lsu_packed[1];
+  assign uop_lsu_vregfile_addr_rvv2lsu_0 = uop_lsu_vregfile_addr_rvv2lsu_packed[0];
+  assign uop_lsu_vregfile_addr_rvv2lsu_1 = uop_lsu_vregfile_addr_rvv2lsu_packed[1];
+  assign uop_lsu_vregfile_data_rvv2lsu_0 = uop_lsu_vregfile_data_rvv2lsu_packed[0];
+  assign uop_lsu_vregfile_data_rvv2lsu_1 = uop_lsu_vregfile_data_rvv2lsu_packed[1];
+  assign uop_lsu_v0_data_rvv2lsu_0       = uop_lsu_v0_data_rvv2lsu_packed[0];
+  assign uop_lsu_v0_data_rvv2lsu_1       = uop_lsu_v0_data_rvv2lsu_packed[1];
+
+  // Config state and vector CSR: internal packed structs
+  RVVConfigState config_state_internal;
+  RVVConfigState vector_csr_internal;
+
+  // Extract vl and vtype fields from config_state, zero-extended to 32 bits
+  // RVVConfigState packed layout (MSB first, no ZVE32F):
+  //   vill(1), vl(8), vstart(7), ma(1), ta(1), xrm(2), xsat(1), sew(3), lmul(3), lmul_orig(3)
+  assign config_state_vl    = {24'b0, config_state_internal.vl};
+  // vtype = {vill, 0, 0, ma, ta, 0, sew[2:0], lmul[2:0]} per RISC-V spec encoding
+  // But CPU.lean just maps 32 bits of "vtype" - provide the relevant fields zero-extended
+  assign config_state_vtype = {24'b0,
+                               config_state_internal.vill,
+                               config_state_internal.ma,
+                               config_state_internal.ta,
+                               config_state_internal.sew,
+                               config_state_internal.lmul};
+
+  // Trap data output (unused by CPU portmap, just expose valid)
+  RVVInstruction trap_data_internal;
+
+  // ROB2RT output (unused by CPU portmap)
+  ROB2RT_t [`NUM_RT_UOP-1:0] rd_rob2rt_unused;
+
+  // ---------------------------------------------------------------
+  // RvvCore instantiation
+  // ---------------------------------------------------------------
+  RvvCore #(
+    .N(4),
+    .RegDataT(logic [31:0]),
+    .VRegDataT(logic [127:0]),
+    .RegAddrT(logic [4:0]),
+    .MaskT(logic [15:0])
+  ) u_rvv_core (
+    .clk                        (clk),
+    .rstn                       (rstn),
+
+    .vstart                     (vstart),
+    .vxrm                       (vxrm),
+    .vxsat                      (vxsat),
+    .frm                        (frm),
+
+    .inst_valid                 (inst_valid),
+    .inst_data                  (inst_data_packed),
+    .inst_ready                 (inst_ready),
+
+    .reg_read_valid             (reg_read_valid),
+    .reg_read_data              ({reg_read_data_packed[7], reg_read_data_packed[6],
+                                  reg_read_data_packed[5], reg_read_data_packed[4],
+                                  reg_read_data_packed[3], reg_read_data_packed[2],
+                                  reg_read_data_packed[1], reg_read_data_packed[0]}),
+
+    .freg_read_data             ({freg_read_data_packed[3], freg_read_data_packed[2],
+                                  freg_read_data_packed[1], freg_read_data_packed[0]}),
+
+    .reg_write_valid            (reg_write_valid),
+    .reg_write_addr             ({reg_write_addr_packed[3], reg_write_addr_packed[2],
+                                  reg_write_addr_packed[1], reg_write_addr_packed[0]}),
+    .reg_write_data             ({reg_write_data_packed[3], reg_write_data_packed[2],
+                                  reg_write_data_packed[1], reg_write_data_packed[0]}),
+
+    .async_rd_valid             (async_rd_valid),
+    .async_rd_addr              (async_rd_addr),
+    .async_rd_data              (async_rd_data),
+    .async_rd_ready             (async_rd_ready),
+
+    .async_frd_valid            (async_frd_valid),
+    .async_frd_addr             (async_frd_addr),
+    .async_frd_data             (async_frd_data),
+    .async_frd_ready            (async_frd_ready),
+
+    .uop_lsu_valid_rvv2lsu      (uop_lsu_valid_rvv2lsu),
+    .uop_lsu_idx_valid_rvv2lsu  (uop_lsu_idx_valid_rvv2lsu),
+    .uop_lsu_idx_addr_rvv2lsu   ({uop_lsu_idx_addr_rvv2lsu_packed[1],
+                                  uop_lsu_idx_addr_rvv2lsu_packed[0]}),
+    .uop_lsu_idx_data_rvv2lsu   ({uop_lsu_idx_data_rvv2lsu_packed[1],
+                                  uop_lsu_idx_data_rvv2lsu_packed[0]}),
+    .uop_lsu_vregfile_valid_rvv2lsu (uop_lsu_vregfile_valid_rvv2lsu),
+    .uop_lsu_vregfile_addr_rvv2lsu  ({uop_lsu_vregfile_addr_rvv2lsu_packed[1],
+                                      uop_lsu_vregfile_addr_rvv2lsu_packed[0]}),
+    .uop_lsu_vregfile_data_rvv2lsu  ({uop_lsu_vregfile_data_rvv2lsu_packed[1],
+                                      uop_lsu_vregfile_data_rvv2lsu_packed[0]}),
+    .uop_lsu_v0_valid_rvv2lsu   (uop_lsu_v0_valid_rvv2lsu),
+    .uop_lsu_v0_data_rvv2lsu    ({uop_lsu_v0_data_rvv2lsu_packed[1],
+                                  uop_lsu_v0_data_rvv2lsu_packed[0]}),
+    .uop_lsu_ready_lsu2rvv      (uop_lsu_ready_lsu2rvv),
+
+    .uop_lsu_valid_lsu2rvv      (uop_lsu_valid_lsu2rvv),
+    .uop_lsu_addr_lsu2rvv       ({uop_lsu_addr_lsu2rvv_packed[1],
+                                  uop_lsu_addr_lsu2rvv_packed[0]}),
+    .uop_lsu_wdata_lsu2rvv      ({uop_lsu_wdata_lsu2rvv_packed[1],
+                                  uop_lsu_wdata_lsu2rvv_packed[0]}),
+    .uop_lsu_last_lsu2rvv       (uop_lsu_last_lsu2rvv),
+    .uop_lsu_ready_rvv2lsu      (uop_lsu_ready_rvv2lsu),
+
+    .vcsr_valid                 (vcsr_valid),
+    .vector_csr                 (vector_csr_internal),
+    .vcsr_ready                 (vcsr_ready),
+
+    .config_state_valid         (config_state_valid),
+    .config_state               (config_state_internal),
+
+    .rvv_idle                   (rvv_idle),
+    .queue_capacity             (queue_capacity),
+
+    .rd_rob2rt_o                (rd_rob2rt_unused),
+
+    .trap_valid_o               (trap_valid_o),
+    .trap_data_o                (trap_data_internal),
+
+    .wr_vxsat_valid_o           (wr_vxsat_valid_o),
+    .wr_vxsat_o                 (wr_vxsat_o)
+  );
+
+endmodule
diff --git a/hdl/verilog/rvv/rvv_pkg.sv b/hdl/verilog/rvv/rvv_pkg.sv
new file mode 100644
index 0000000..b079256
--- /dev/null
+++ b/hdl/verilog/rvv/rvv_pkg.sv
@@ -0,0 +1,9 @@
+// Pull in all RVV defines and types for the compilation unit.
+// Must be compiled before any other RVV source files.
+`include "rvv_backend_define.svh"
+`include "rvv_backend_config.svh"
+`include "rvv_backend.svh"
+`include "rvv_backend_alu.svh"
+`include "rvv_backend_dispatch.svh"
+`include "rvv_backend_div.svh"
+`include "rvv_backend_pmtrdt.svh"
